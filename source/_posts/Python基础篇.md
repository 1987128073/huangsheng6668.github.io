---
title: Python基础篇 
date: 2020-03-14 15:55:57 
tags: python 
categories: python 
---
#### 列表（list）：
##### 列表里的类型：

* **列表里的类型可以是任意的**
* **列表的基本单位是元素**
* **列表是动态的，它的长度是可变的，理论上容量是无限大！！！**
* **list有2种特殊的生成方式,一种是list(range(num)),一种是[i for i in range(num)]，其中[i for i in range(num)]可变形为[m+n for m in [任意类型数据] for n in 任意类型数据]**
![8GUkdK.png](https://s1.ax1x.com/2020/03/16/8GUkdK.png)


* **列表不像数组一样，只能存放一种数据类型，如['小明', 17, 1.0]是可以这样存储的**
* **列表可以由多个小列表组成，我们想从中取出这些列表，需要借助切片。使用切片取出来的值还是个切片，所以说一个列表可以由多个列表组成！！！**
*  **列表的偏移量是可以为负值的，不管负数是多少，最终都指向最后一个元素。**

**切片的写法：**

    1. list[:] : 从0取值到最后一个元素
    2. list[:2] : 从0取到1共两个元素
    3. list[:-1]:从0取到最后，结果跟第一个相同
    4.list[:-1:2]:从0取到最后，每两个取一个，也就是步幅为2，如图：
![8GUayn.png](https://s1.ax1x.com/2020/03/16/8GUayn.png)

    切片的口决：左右空，取到头；左要取，右不取。
    意思是如上的写法，左闭右开，冒号左边的元素开始取值，直到冒号右边的偏移量-1的位置。

  #### 特别标注！！！！字符串也是能使用切片的，比如下图的去空操作，返回的是一个字符串：
![8GUsFU.png](https://s1.ax1x.com/2020/03/16/8GUsFU.png)
#### 列表的基本操作：

* **增加一个元素到列表末尾的位置：list.append(),作用跟栈的增加一个元素是一个意思。注意：append（）括号里面只能接受一个参数，参数可以是个对象，列表，字典，这些参数的内部可以是多个，但是append()括号里面只能写一个参数，参数里面可以包含其他参数，如 list.append([1,2])，list.append是没有返回值的，比如下图**
![8Qhg9P.png](https://s1.ax1x.com/2020/03/14/8Qhg9P.png)
* 根据索引使用del()删除一个列表元素,
del 列表名[元素的索引],**注意是中括号！！！！**，具体使用如图，这里踩过坑：
![8Qh6ht.png](https://s1.ax1x.com/2020/03/14/8Qh6ht.png)

* 使用pop()弹出栈，并返回弹出的值如：
students = [1,2,3]
int i = students.pop()
i == 3,与**Java不同的是pop()函数括号内可以指定弹出数的下标**

* **list1.extend(list2)将两个list合并起来，也可以直接把两个list加起来如list3 = list1 + list2**如图：
![8Qhhng.png](https://s1.ax1x.com/2020/03/14/8Qhhng.png)
**extend()括号里面是字符串时，字符串里的每个字符将被拆分出来组成一个列表并跟原list拼接，如果是list则直接拼接**

* sorted()与sort()排序
**sorted(list)返回一个排序好的list的副本，原list没有发生变化,而list.sort()是会改变原list**
![8Qh4BQ.png](https://s1.ax1x.com/2020/03/14/8Qh4BQ.png)


   #### 字典(dict)
   **字典是由一个个键值对构成的，每一个键值对算一个长度。如下图：**
![8Qh57j.png](https://s1.ax1x.com/2020/03/14/8Qh57j.png)  
  ---
#### 字典的值的提取方法
*  **字典的键具有唯一性，而值是可以重复的。提取值的方式为“字典名['键名']”**
*  **使用get('键名','默认值')的方法提取值，当键名不存在时，返回默认值**
*  使用setDefault(键名,默认值)获取字典值，倘若不存在该键值对，则会创建值为设置的默认值
---
   **字典的基本单位是键值对**

---
   #### 字典的操作:
   **删除**字典里的键值：del 字典名['键名']
   给字典里的元素**赋值**: 字典名['键'] = 值
   **获取字典所有键** : 字典名.keys()
   **获取字典的所有值**： 字典名.values()
   **获取字典的所有键值对**: 字典名.items()

   #### 列表与字典的异同：
   ##### 异：

*     字典是无序的，而列表是有序的，如下图：
![8QhTNn.png](https://s1.ax1x.com/2020/03/14/8QhTNn.png)
**自从Python3.6之后，字典就是有序的啦！**


##### 同：
*   若要修改，都可以通过赋值来进行
*   支持任意嵌套

#### 元组
元组和列表都是序列，提取的方式也是偏移量，也同样支持切片的方式提取

**元组是静态的，长度大小固定，无法增加删减或者改（immutable**

元组里的参数一旦定义便不可变，如图
![8Qhb90.png](https://s1.ax1x.com/2020/03/14/8Qhb90.png)

语法：元祖名（元素）

元组也支持任意嵌套

#### 常用模块：
time
引用: import time
**一般用于休眠，相当于java的sleep，因为功能一致time.sleep(秒)**

random
引用 import random
**一般用于产生随机数，random.randint(a,b)
函数返回一个介于a与b之间且包括a,b的值**
**random.randint(list)通过该方法随机从list中抽取一个值，而dict字典则无法随机抽取如图**
![8Qhq3V.png](https://s1.ax1x.com/2020/03/14/8Qhq3V.png)
![8QTMdg.png](https://s1.ax1x.com/2020/03/14/8QTMdg.png)
**random.sample(seq, n)需要传递两个参数，第一个参数是一个序列（列表、字符串、元组），第二个参数是随机选取的元素个数,该函数是用于随机从集合当中抽取元素**
![8QhjuF.png](https://s1.ax1x.com/2020/03/14/8QhjuF.png)

#### 整型(int)
python3.x中，**整型(int) 的长度理论上是无限的**
![8QhvB4.png](https://s1.ax1x.com/2020/03/14/8QhvB4.png)

关于整型呢有几种常用的操作：
![8Q4SE9.png](https://s1.ax1x.com/2020/03/14/8Q4SE9.png)
虽然操作简单但有两个点需要注意：

1. ** 代表着某个数的几次方，比如上图2 ** 3=8
2. 3/1 = 3.0,这里可以看出来，**整型经过除法运算结果变为了浮点数**




#### 关于格式符

为了更方便地实现不同数据类型的拼接，用【格式符%】%号后面的字母叫做类型码。
**常见的类型码**
![8Q4pNR.png](https://s1.ax1x.com/2020/03/14/8Q4pNR.png)

示例如图：
![8Q4P9x.png](https://s1.ax1x.com/2020/03/14/8Q4P9x.png)

这两个 是等价的，但是后者明显就方便好多，不论是
**更详细的示例**：
![8Q4i36.png](https://s1.ax1x.com/2020/03/14/8Q4i36.png)

**当两种类型码显示的结果都一样时可以任意选用**如图：
![8Q4EuD.png](https://s1.ax1x.com/2020/03/14/8Q4EuD.png)

#### 关于变量作用域

1. 在一个函数内定义的变量仅能在函数内部使用（局部作用域），它们被称作【局部变量】。
2. 
在所有函数之外赋值的变量，可以在程序的任何位置使用（全局作用域），它们叫【全局变量】.
关于局部变量和全局变量这点要注意，当局部变量跟全局变量同名时，在局部变量重新赋值并不影响全局变量，如图：
![8Q4VDe.png](https://s1.ax1x.com/2020/03/14/8Q4VDe.png)
![8Q4ZHH.png](https://s1.ax1x.com/2020/03/14/8Q4ZHH.png)

![8Q4nUA.png](https://s1.ax1x.com/2020/03/14/8Q4nUA.png)

**若要把局部变量变为全局变量，在局部变量前加global前缀，python不运行同时声明global并赋值，如图**
![8Q4u4I.png](https://s1.ax1x.com/2020/03/14/8Q4u4I.png)


#### 浅谈全局变量和局部变量
**1.当全局变量没有声明时，在函数内部是不能使用global进行修饰，因为global声明变量是为了使用已存在的全局变量，当全局变量不存在时，global就无法定位全局变量。**
![8Q4Q8P.png](https://s1.ax1x.com/2020/03/14/8Q4Q8P.png)
**2.当函数内部声明了一个与全局变量同名的局部变量，若需要在声明之前使用全局变量必须用global显示声明，若没声明将会报未声明变量的错**
![8Q4lgf.png](https://s1.ax1x.com/2020/03/14/8Q4lgf.png)
正确做法：
![8Q41v8.png](https://s1.ax1x.com/2020/03/14/8Q41v8.png)

**注意，当在函数内部声明了global使用全局变量的时候，后续的关于该变量同名的操作实际上对该全局变量的重新赋值**
![8Q48KS.png](https://s1.ax1x.com/2020/03/14/8Q48KS.png)


#### 列表和元组的差异
**存储方式上：元组是静态的，而列表是动态的，所以存储方式肯定有所差异**，如下图：
![8QTAJA.png](https://s1.ax1x.com/2020/03/14/8QTAJA.png)
原因：
**由于列表是动态的，所以需要存储指针来指向对应元素，列表和元组的存储大小主要是由存储的数据类型来决定的**，如int型，其在内存中占据8个字节，如上图，三个元素就需要两个指针来追踪列表空间使用情况，所以列表比元组多16个字节，当元素个数增多指针的个数也会相应增加。如下图：
![8QTCZD.png](https://s1.ax1x.com/2020/03/14/8QTCZD.png)

**为了减小每次增加 / 删减操作时空间分配的开销Python 每次分配空间时都会额外多分配一些，这样的机制（over-allocating）保证了其操作的高效性：增加 / 删除的时间复杂度均为 O(1)**

**元组因为其长度大小固定，元素不可变，所以其存储空间一旦固定则无法更改。
**





























